#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     motorC,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorD,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     motorA,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorB,        tmotorTetrix, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


/*--------------------------------------------------------------------------------------------------------*\
|*                                                                                                        *|
|*                                    - Tetrix Simple Tank Drive -                                        *|
|*                                          ROBOTC on Tetrix                                              *|
|*                                                                                                        *|
|*  This program allows you to drive a robot via remote control using the ROBOTC Debugger.                *|
|*  This particular method uses "Tank Drive" where each side is controlled individually like a tank.      *|
|*                                                                                                        *|
|*                                        ROBOT CONFIGURATION                                             *|
|*    NOTES:                                                                                              *|
|*                                                                                                        *|
|*    MOTORS & SENSORS:                                                                                   *|
|*    [I/O Port]              [Name]              [Type]              [Description]                       *|
|*    Port D                  motorD              12V                 Right motor                         *|
|*    Port E                  motorE              12V                 Left motor                          *|
\*---------------------------------------------------------------------------------------------------4246-*/


#include "JoystickDriver.c"
float angle, magnitude;
int threshold = 40;
task main()
{


  while(true)
  {
  magnitude = sqrt((joystick.joy1_x1)*(joystick.joy1_x1)+(joystick.joy1_y1)*(joystick.joy1_y1));
  angle = asin((joystick.joy1_y1)*magnitude);
  writeDebugStream("int x is: %d", magnitude);
  writeDebugStream("int angle is: %d", angle);
    getJoystickSettings(joystick);
    if(abs(joystick.joy1_x2) > threshold){
    motor[motorA] = joystick.joy1_x2;
    motor[motorB] = joystick.joy1_x2;
    motor[motorD] = -joystick.joy1_x2;
    motor[motorC] = joystick.joy1_x2;
  }
  else if(abs(joystick.joy1_x1) > threshold || abs(joystick.joy1_y1) > threshold){
  if(abs(joystick.joy1_x1) > threshold && abs(joystick.joy1_y1) > threshold){
motor[motorA] = joystick.joy1_x1;
    motor[motorD] = joystick.joy1_x1;
    motor[motorB] = joystick.joy1_y1;
    motor[motorC] = -joystick.joy1_y1;
  }
  else{
  if(abs(joystick.joy1_x1) > threshold){
motor[motorA] = joystick.joy1_x1;
    motor[motorD] = joystick.joy1_x1;
    motor[motorB] = 0;
    motor[motorC] = 0;
    }
    if(abs(joystick.joy1_y1) > threshold){
motor[motorA] = 0;
    motor[motorD] = 0;
    motor[motorB] = joystick.joy1_y1;
    motor[motorC] = -joystick.joy1_y1;
    }
    }
    }
    else{
    motor[motorA] = 0;
    motor[motorD] = 0;
    motor[motorB] = 0;
    motor[motorC] = 0;
  }






  }
}